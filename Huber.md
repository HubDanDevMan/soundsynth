## Huber, Daniel
## G4b


# Soundsynthesizer

### Overview

The result is a Python module called sndmath that can be imported and used to generate tones with the correct pitch and duration.

### Building and running

Type `make install` to build the c files. It runs the `setup.py` file and builds the python module. Compiling might only work with `gcc` installed due to 
compiler specific macros. The module can be used by importing sndmath in python (make sure correct version number is used for compilation and interpreter
invocation) and calling the functions create\_melody(melodystr, filename, oscillator). The melody string must have the following format:
```
syntax	= note, {WHITESPACE}, {note};
note	= DURATION, (TONE, OCTAVENUMBER) | PAUSE;
duration= float;
TONE	= KEY;
PAUSE	= "p" | "P"
KEY	= ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "A" | "B" | "C" | "D" | "E" | "F" | "G"), ["#"];
WHITESPACE = " " | "\n" | "\t"
NOTE: There is no E# and no B#
```
Example melody code:
`0.5 e#4 0.5C3	1.0D3`

There is also a function `create_melodies` which takes a tuple of multiple melody strings instad of a single melody string. The remaining args are
identical to `create_melody`. The output file will contain raw little-endian float PCM values ranging from -1.0 to 1.0. It can be played by using
the `play --volume 2.0 --endian little -r 44100 -c 1 -e floating-point -b 32 \<OUTPUT_FILE\>` command. The osc arg is a integer and is intended to
be one of the following:
- sndmath.SIN
- sndmath.SAW
- sndmath.SQUARE
- sndmath.SQUAREDSERIES
- sndmath.NOISE

### Reflexion

I feel that reaching my target goals was not that difficult. The melodyparser was not that difficult to implement. I am taking a bit of a short cut in
fixing a bug, namely ignoring it. When the melodystring specifies a duration followed immediatly by an 'E', the `atof()` function parses the letter 'E'
as an exponent, raising the duration to the octave number that follows the 'E'. Instead of checking for said case, the program just returns an error.
Therefore, I recommend that every duration and tone in the melody string is separated by a whitespace character. The music theory aspect, especially
creating the correct wave length and amplitude was also trivial to me, because I recently had the topic oscillations in physics. I decided to extend
my program with functions that approach the sound of a piano, this was the second most difficult part of my project. Sounds generated by non-digital
instruments are very complex and unique. These instruments contain harmonic overtones, i.e. they resonate on the base frequency as well as some positive
integer multiples of the base frequency. I use maximum 16 harmonic overtones in my program. The amplitude of the individual harmonic overtones varies from
instrument to instrument and I tried to approach the sound of a piano using a spectrogram analyzer referenced in the sources. Compared with
a real piano, my program's result analyzed with the spectrogram looks quite similar to the real pianos spectrogram. 
Because a piano produces a tone by hitting a string with a hammer, the tone
contains a clicky sound in the beginning. I produced this click with the function `pianoStroke()`. I didn't really have to debug the aforementioned but
I had to adjust the parameters of the waves that generate the clicky sound. Clicky sound is produced by inharmonic overtones of the base frequency.
This means the overtones are non-integer multiples of the base frequency. The overtones also change over time when the note is played. This change
of overtone amplitude is done in the function `dynamicOvertones()` and it makes the sound feel much more natural. An Instruments loudness also changes
over time and in my program I accomplished this using envelopes. Envelopes describe how the sound loudness changes over time. A good source on envelopes
and how they work is on Wikipedia, the link is listed in the sources. The envelope is applied in the function `pianoNote()`, which generates a piano note.
I have put in a lot of effort into approaching the piano sound, but it wasn't actually not a target goal and I did it because I got slightly carried away.
The last target goal was writing the python interface part of my program. All functions and constants that will be used inside the Python module are in
the file `sndmath.c`. It contains the three functions that users can call from Python:

- `create_melody(melodystr, filename, osc)`
- `create_melodies(melodystr, filename, osc)`
- `create_instrument(melodystr, filename, instrument_enum)`

I haven't managed to write a `create_instruments()` function, I don't have enough time for that yet. But the core target goal of writing a Python module
was reached. I often encountered errors when allocating memory because I malloc'd only the count of floats instead of the count of floats times the size
of a float. The debugging process of a Python C extension is completely different to debugging regular C programs. Especially
memory debugging errors are a lot harder to debug. I tried using `valgrind` but I couldn't really get it to understand what went wrong. Because Python
uses reference counting, I had to learn how to use refcount. Memory handling with malloc() and free() can be cumbersome to debug, but with `Py\_DECREF()`
`Py\_INCREF()` I was struggling a bit. Refcounting is a new paradigm to me and a few times I suspected that there were some errors in my C extension. In the beginning. When I ran a demo
program a few hundred times, the memory consumption increased by a lot. Now I managed to find the errors and I am confident there are no leaks now.
I think that languages such as Rust are really beneficial to counter memory leaks. But because I used C I had to improvise a bit. Debugging was made
possible by creating and using the `DEBUG` macro which can be toggle on and off in the `debug.h` file. Parsing the debug logs can be a bit difficult,
therefore I added automatic file and line numbering to every debug log line.
Overall, I really liked that I wrote a Python C extension, I learned a lot in this process. I also got a better understanding of music synthesis theory. But I
had difficulties debugging the C extension while it was running, which is why I will try to improve my knowledge of memory debuggers such as valgrind.


### Sources
[C API Introduction Tutorial by RealPython](https://realpython.com/build-python-c-extension-module/)
[C Standart Library Documentation](https://www.tutorialspoint.com/c_standard_library/index.htm)
[Python C API](https://docs.python.org/3/c-api/index.html)
[Wikipedia Synthesizer](https://en.wikipedia.org/wiki/Synthesizer)
[Envelopes](https://en.wikipedia.org/wiki/Envelope_(music))
[Piano Harmonics](https://spectrogram.sciencemusic.org/)
[GCC Macro Manual](https://gcc.gnu.org/onlinedocs/cpp/Macros.html)
